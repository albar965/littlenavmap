/*****************************************************************************
* Copyright 2015-2024 Alexander Barthel alex@littlenavmap.org
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*****************************************************************************/

#include "search/logdatasearch.h"

#include "atools.h"
#include "common/constants.h"
#include "common/mapcolors.h"
#include "common/maptypesfactory.h"
#include "common/maptypes.h"
#include "common/mapresult.h"
#include "common/unit.h"
#include "common/formatter.h"
#include "gui/widgetstate.h"
#include "gui/widgetutil.h"
#include "app/navapp.h"
#include "query/airportquery.h"
#include "search/column.h"
#include "search/columnlist.h"
#include "search/sqlcontroller.h"
#include "ui_mainwindow.h"
#include "sql/sqlrecord.h"

#include <QDateTime>

LogdataSearch::LogdataSearch(QMainWindow *parent, QTableView *tableView, si::TabSearchId tabWidgetIndex)
  : SearchBaseTable(parent, tableView, new ColumnList("logbook", "logbook_id"), tabWidgetIndex)
{
  /* *INDENT-OFF* */
  ui->pushButtonLogdataHelp->setToolTip(
    "<p>All set search conditions have to match.</p>"
    "<p>Search tips for text fields: </p>"
    "<ul>"
      "<li>Default is search for logbook entries that contain the entered text.</li>"
      "<li>Use &quot;*&quot; as a placeholder for any text. </li>"
      "<li>Use double quotes like &quot;EKSN&quot; to force exact search.</li>"
      "<li>Prefix with &quot;-&quot; as first character to negate search.</li>"
    "</ul>");
  /* *INDENT-ON* */

  // All widgets that will have their state and visibility saved and restored
  logdataSearchWidgets =
  {
    ui->horizontalLayoutLogdata,
    ui->verticalLayoutLogdataMore,
    ui->horizontalLayoutLogdataDist,
    ui->actionSearchLogdataFollowSelection,
    ui->lineLogdataMore,
    ui->lineLogdataMoreDist,
    ui->actionLogdataSearchShowMoreOptions,
    ui->actionLogdataSearchShowDistOptions
  };

  // All drop down menu actions
  logdataSearchMenuActions =
  {
    ui->actionLogdataSearchShowMoreOptions, ui->actionLogdataSearchShowDistOptions
  };

  // Default view column descriptors
  // Hidden columns are part of the query and can be used as search criteria but are not shown in the table
  // Columns that are hidden are also needed to fill MapAirport object and for the icon delegate
  columns->
  append(Column("logbook_id").hidden()).
  append(Column("departure_time", tr("Departure\nReal Local Time")).defaultSort(true).defaultSortOrder(Qt::DescendingOrder)).
  append(Column("departure_time_sim", tr("Departure\nSim. Time UTC"))).
  append(Column("departure_ident", ui->lineEditLogdataDeparture, tr("Departure\nIdent")).filterByBuilder()).
  append(Column("departure_name", tr("Departure"))).
  append(Column("departure_runway").hidden()).

  // Virtual columns generated by a SQL function
  append(Column("travel_time", tr("Travel\nReal Time")).
         sqlFunc("strftime('%s', destination_time) - strftime('%s', departure_time)")).
  append(Column("travel_time_sim", tr("Travel\nSim. Time")).
         sqlFunc("strftime('%s', destination_time_sim) - strftime('%s', departure_time_sim)")).

  append(Column("destination_time", tr("Destination\nReal Local Time"))).
  append(Column("destination_time_sim", tr("Destination\nSim. Time UTC"))).
  append(Column("destination_ident", ui->lineEditLogdataDestination, tr("Destination\nIdent")).filterByBuilder()).
  append(Column("destination_name", tr("Destination"))).
  append(Column("destination_runway").hidden()).
  append(Column("aircraft_name", ui->lineEditLogdataAircraftModel,
                tr("Aircraft\nModel")).filter(true, ui->actionLogdataSearchShowMoreOptions)).
  append(Column("aircraft_registration", ui->lineEditLogdataAircraftRegistration,
                tr("Aircraft\nRegistration")).filter(true, ui->actionLogdataSearchShowMoreOptions)).
  append(Column("aircraft_type", ui->lineEditLogdataAircraftType, tr("Aircraft\nType")).filter()).
  append(Column("simulator", ui->lineEditLogdataSimulator, tr("Simulator")).filter(true, ui->actionLogdataSearchShowMoreOptions)).
  append(Column("performance_file").hidden()).
  append(Column("flightplan_file").hidden()).
  append(Column("distance", tr("Distance\nPlan %dist%"))).
  append(Column("distance_flown", tr("Distance\nFlown %dist%"))).
  append(Column("flightplan_cruise_altitude", tr("Cruise\nAltitude %alt%"))).
  append(Column("route_string").hidden()).
  append(Column("description", ui->lineEditLogdataDescription, tr("Remarks")).filter(true, ui->actionLogdataSearchShowMoreOptions)).
  append(Column("departure_lonx").hidden()).
  append(Column("departure_laty").hidden()).
  append(Column("departure_alt").hidden()).
  append(Column("destination_lonx").hidden()).
  append(Column("destination_laty").hidden()).
  append(Column("destination_alt").hidden());

  // Assign the callback which builds the where clause for the airport search ======================
  columns->setQueryBuilder(QueryBuilder(std::bind(&SearchBaseTable::queryBuilderFunc, this, std::placeholders::_1),
                                        {QueryWidget(ui->lineEditLogdataAirport, {"departure_ident", "destination_ident"},
                                                     false /* allowOverride */, false /* allowExclude */)}));

  SearchBaseTable::initViewAndController(NavApp::getDatabaseLogbook());

  // Add model data handler and model format handler as callbacks
  setCallbacks();
}

LogdataSearch::~LogdataSearch()
{
}

void LogdataSearch::connectSearchSlots()
{
  SearchBaseTable::connectSearchSlots();

  // Small push buttons on top
  connect(ui->pushButtonLogdataClearSelection, &QPushButton::clicked, this, &SearchBaseTable::nothingSelectedTriggered);
  connect(ui->pushButtonLogdataReset, &QPushButton::clicked, this, &SearchBaseTable::resetSearch);

  // Install filter for cursor down action
  installEventFilterForWidget(ui->lineEditLogdataAirport);
  installEventFilterForWidget(ui->lineEditLogdataDeparture);
  installEventFilterForWidget(ui->lineEditLogdataDestination);
  installEventFilterForWidget(ui->lineEditLogdataAircraftType);
  installEventFilterForWidget(ui->lineEditLogdataAircraftRegistration);
  installEventFilterForWidget(ui->lineEditLogdataAircraftModel);
  installEventFilterForWidget(ui->lineEditLogdataDescription);
  installEventFilterForWidget(ui->lineEditLogdataSimulator);

  columns->assignMinMaxWidget("distance", ui->spinBoxLogdataMinDist, ui->spinBoxLogdataMaxDist);

  // Connect widgets to the controller
  SearchBaseTable::connectSearchWidgets();
  ui->toolButtonLogdata->addActions({ui->actionLogdataSearchShowMoreOptions, ui->actionLogdataSearchShowDistOptions});

  // Drop down menu actions
  connect(ui->actionLogdataSearchShowMoreOptions, &QAction::toggled, this, [this](bool state) {
    buttonMenuTriggered(ui->verticalLayoutLogdataMore, ui->lineLogdataMore, state, false /* distanceSearch */);
  });

  connect(ui->actionLogdataSearchShowDistOptions, &QAction::toggled, this, [this](bool state) {
    buttonMenuTriggered(ui->horizontalLayoutLogdataDist, ui->lineLogdataMoreDist, state, false /* distanceSearch */);
  });

  ui->actionLogdataEdit->setShortcutContext(Qt::WidgetWithChildrenShortcut);
  ui->actionLogdataAdd->setShortcutContext(Qt::WidgetWithChildrenShortcut);
  ui->actionLogdataDelete->setShortcutContext(Qt::WidgetWithChildrenShortcut);
  ui->actionLogdataCleanup->setShortcutContext(Qt::WidgetWithChildrenShortcut);

  ui->tableViewLogdata->addActions({ui->actionLogdataEdit, ui->actionLogdataAdd, ui->actionLogdataDelete, ui->actionLogdataCleanup});

  connect(ui->pushButtonLogdataEdit, &QPushButton::clicked, this, &LogdataSearch::editLogEntriesTriggered);
  connect(ui->actionLogdataEdit, &QAction::triggered, this, &LogdataSearch::editLogEntriesTriggered);

  connect(ui->pushButtonLogdataDel, &QPushButton::clicked, this, &LogdataSearch::deleteLogEntriesTriggered);
  connect(ui->actionLogdataDelete, &QAction::triggered, this, &LogdataSearch::deleteLogEntriesTriggered);

  connect(ui->pushButtonLogdataAdd, &QPushButton::clicked, this, &LogdataSearch::addLogEntryTriggered);
  connect(ui->actionLogdataAdd, &QAction::triggered, this, &LogdataSearch::addLogEntryTriggered);

  connect(ui->actionLogdataCleanup, &QAction::triggered, this, &LogdataSearch::cleanupLogEntries);
}

void LogdataSearch::addLogEntryTriggered()
{
  emit addLogEntry();
}

void LogdataSearch::editLogEntriesTriggered()
{
  emit editLogEntries(getSelectedIds());
}

void LogdataSearch::deleteLogEntriesTriggered()
{
  QVector<int> selectedIds = getSelectedIds();
  emit deleteLogEntries(QSet<int>(selectedIds.constBegin(), selectedIds.constEnd()));
}

void LogdataSearch::saveState()
{
  atools::gui::WidgetState widgetState(lnm::SEARCHTAB_LOGDATA_VIEW_WIDGET);
  widgetState.save(logdataSearchWidgets);
}

void LogdataSearch::restoreState()
{
  atools::gui::WidgetState widgetState(lnm::SEARCHTAB_LOGDATA_VIEW_WIDGET);
  if(OptionData::instance().getFlags().testFlag(opts::STARTUP_LOAD_SEARCH) && !atools::gui::Application::isSafeMode())
    widgetState.restore(logdataSearchWidgets);
  else
  {
    QList<QObject *> objList;
    atools::convertList(objList, logdataSearchMenuActions);
    widgetState.restore(objList);

    atools::gui::WidgetState(lnm::SEARCHTAB_LOGDATA_VIEW_WIDGET).restore(ui->tableViewLogdata);
  }

  finishRestore();
}

void LogdataSearch::saveViewState(bool)
{
  atools::gui::WidgetState(lnm::SEARCHTAB_LOGDATA_VIEW_WIDGET).save(ui->tableViewLogdata);
}

void LogdataSearch::restoreViewState(bool)
{
  atools::gui::WidgetState(lnm::SEARCHTAB_LOGDATA_VIEW_WIDGET).restore(ui->tableViewLogdata);
}

/* Callback for the controller. Will be called for each table cell and should return a formatted value */
QVariant LogdataSearch::modelDataHandler(int colIndex, int rowIndex, const Column *col, const QVariant&,
                                         const QVariant& displayRoleValue, Qt::ItemDataRole role) const
{
  switch(role)
  {
    case Qt::DisplayRole:
      return formatModelData(col, displayRoleValue);

    case Qt::TextAlignmentRole:
      // Align all numeric columns right
      if(col->getColumnName().endsWith("_ident") || col->getColumnName() == "distance" ||
         col->getColumnName().startsWith("departure_time") || col->getColumnName().startsWith("destination_time") ||
         col->getColumnName() == "travel_time" || col->getColumnName() == "travel_time_sim" ||
         displayRoleValue.type() == QVariant::Int || displayRoleValue.type() == QVariant::UInt ||
         displayRoleValue.type() == QVariant::LongLong || displayRoleValue.type() == QVariant::ULongLong ||
         displayRoleValue.type() == QVariant::Double)
        return Qt::AlignRight;

      break;
    case Qt::BackgroundRole:
      // Use another alternating color if this is a field in the sort column
      if(colIndex == controller->getSortColumnIndex())
        return mapcolors::alternatingRowColor(rowIndex, true);

      break;
    case Qt::ToolTipRole:
      if(col->getColumnName() == "description")
        return atools::elideTextLinesShort(displayRoleValue.toString(), 40);

      break;

    case Qt::FontRole:
      if(col->getColumnName().endsWith("_ident"))
      {
        QFont font = view->font();
        font.setBold(true);
        return font;
      }

      break;

    default:
      break;
  }

  return QVariant();
}

/* Formats the QVariant to a QString depending on column name */
QString LogdataSearch::formatModelData(const Column *col, const QVariant& displayRoleValue) const
{
  // Called directly by the model for export functions
  if(col->getColumnName().startsWith("departure_time") || col->getColumnName().startsWith("destination_time"))
    return QLocale().toString(displayRoleValue.toDateTime(), QLocale::NarrowFormat);
  else if(col->getColumnName() == "travel_time" || col->getColumnName() == "travel_time_sim")
  {
    // Virtual columns from SQL functions
    if(displayRoleValue.isNull())
      return QString();
    else
      return formatter::formatMinutesHours(displayRoleValue.toDouble() / 3600.);
  }
  else if(col->getColumnName() == "distance" || col->getColumnName() == "distance_flown")
    return Unit::distNm(displayRoleValue.toFloat(), false, 0);
  else if(col->getColumnName() == "flightplan_cruise_altitude")
  {
    if(displayRoleValue.isNull())
      return QString();
    else
      return Unit::altFeet(displayRoleValue.toFloat(), false, 0);
  }
  else if(col->getColumnName() == "description")
    return atools::elideTextShort(displayRoleValue.toString().simplified(), 80);
  else if(displayRoleValue.type() == QVariant::Int || displayRoleValue.type() == QVariant::UInt)
    return QLocale().toString(displayRoleValue.toInt());
  else if(displayRoleValue.type() == QVariant::LongLong || displayRoleValue.type() == QVariant::ULongLong)
    return QLocale().toString(displayRoleValue.toLongLong());
  else if(displayRoleValue.type() == QVariant::Double)
    return QLocale().toString(displayRoleValue.toDouble());

  return displayRoleValue.toString();
}

void LogdataSearch::getSelectedMapObjects(map::MapResult& result) const
{
  if(!NavApp::getMainUi()->dockWidgetSearch->isVisible())
    return;

  // Build a SQL record with all available fields
  atools::sql::SqlRecord rec;
  controller->initRecord(rec);
  // qDebug() << Q_FUNC_INFO << rec;

  const QItemSelection& selection = controller->getSelection();
  for(const QItemSelectionRange& rng :  selection)
  {
    for(int row = rng.top(); row <= rng.bottom(); ++row)
    {
      if(controller->hasRow(row))
      {
        controller->fillRecord(row, rec);
        // qDebug() << Q_FUNC_INFO << rec;

        map::MapLogbookEntry entry;
        MapTypesFactory().fillLogbookEntry(rec, entry);

        airportQuery->getAirportByIdent(entry.departure, entry.departureIdent);
        if(!entry.departure.isValid())
          entry.departure = airportQuery->getAirportByOfficialIdent(entry.departureIdent, &entry.departurePos);
        if(entry.departure.isValid())
          result.airports.append(entry.departure);

        airportQuery->getAirportByIdent(entry.destination, entry.destinationIdent);
        if(!entry.destination.isValid())
          entry.destination = airportQuery->getAirportByOfficialIdent(entry.destinationIdent, &entry.destinationPos);
        if(entry.destination.isValid())
          result.airports.append(entry.destination);

        result.logbookEntries.append(entry);
      }
    }
  }
}

void LogdataSearch::postDatabaseLoad()
{
  SearchBaseTable::postDatabaseLoad();
  setCallbacks();
}

/* Sets controller data formatting callback and desired data roles */
void LogdataSearch::setCallbacks()
{
  using namespace std::placeholders;
  controller->setDataCallback(std::bind(&LogdataSearch::modelDataHandler, this, _1, _2, _3, _4, _5, _6),
                              {Qt::DisplayRole, Qt::BackgroundRole, Qt::TextAlignmentRole, Qt::ToolTipRole,
                               Qt::FontRole});
}

/* Update the button menu actions. Add * for changed search criteria and toggle show/hide all
 * action depending on other action states */
void LogdataSearch::updateButtonMenu()
{
  atools::gui::util::changeIndication(ui->actionLogdataSearchShowMoreOptions,
                                      atools::gui::util::anyWidgetChanged({ui->verticalLayoutLogdataMore}));
  atools::gui::util::changeIndication(ui->actionLogdataSearchShowDistOptions,
                                      atools::gui::util::anyWidgetChanged({ui->horizontalLayoutLogdataDist}));
}

void LogdataSearch::updatePushButtons()
{
  QItemSelectionModel *sm = view->selectionModel();
  ui->pushButtonLogdataClearSelection->setEnabled(sm != nullptr && sm->hasSelection());
  ui->pushButtonLogdataDel->setEnabled(sm != nullptr && sm->hasSelection());
  ui->pushButtonLogdataEdit->setEnabled(sm != nullptr && sm->hasSelection());

  // Update actions and keys too
  ui->actionLogdataEdit->setEnabled(sm != nullptr && sm->hasSelection());
  ui->actionLogdataDelete->setEnabled(sm != nullptr && sm->hasSelection());
}

QAction *LogdataSearch::followModeAction()
{
  return ui->actionSearchLogdataFollowSelection;
}
